<!DOCTYPE html>
<!-- saved from url=(0073)https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab -->
<html lang="en-GB"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Corndel DevOps Course Project Exercises | Project Exercises for the Corndel DevOps Apprenticeship</title>
<meta name="generator" content="Jekyll v4.3.3">
<meta property="og:title" content="Corndel DevOps Course Project Exercises">
<meta property="og:locale" content="en_US">
<meta name="description" content="Project Exercises for the Corndel DevOps Apprenticeship">
<meta property="og:description" content="Project Exercises for the Corndel DevOps Apprenticeship">
<meta property="og:site_name" content="Corndel DevOps Course Project Exercises">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Corndel DevOps Course Project Exercises">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Project Exercises for the Corndel DevOps Apprenticeship","headline":"Corndel DevOps Course Project Exercises","url":"/exercises/m7_exercise_gitlab.html"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com/">
    <link rel="preload" href="./Corndel DevOps Course Project Exercises _ Project Exercises for the Corndel DevOps Apprenticeship_files/css" as="style" type="text/css" crossorigin="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="robots" content="noindex, nofollow">
    <link rel="stylesheet" href="./Corndel DevOps Course Project Exercises _ Project Exercises for the Corndel DevOps Apprenticeship_files/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>
  <body>
    <a id="skip-to-content" href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#content">Skip to the content.</a>
    <header class="page-header" role="banner">
      <div class="nav-bar">
        <a href="https://project-exercises.devops.corndel.com/"><img src="./Corndel DevOps Course Project Exercises _ Project Exercises for the Corndel DevOps Apprenticeship_files/shared-home.svg" alt="Home" class="home-icon"></a>
        <img src="./Corndel DevOps Course Project Exercises _ Project Exercises for the Corndel DevOps Apprenticeship_files/shared-corndel-logo.png" class="corndel-logo">
      </div>
      <h1 class="project-name">Corndel DevOps Course Project Exercises</h1>
      <h2 class="project-tagline">Project Exercises for the Corndel DevOps Apprenticeship</h2>
    </header>

    <main id="content" class="main-content" role="main">
      <h1 id="module-7---project-exercise">Module 7 - Project Exercise</h1>

<ul id="markdown-toc">
  <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#module-7---project-exercise" id="markdown-toc-module-7---project-exercise">Module 7 - Project Exercise</a>    <ul>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#part-1-testing-in-docker" id="markdown-toc-part-1-testing-in-docker">Part 1: Testing in Docker</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#part-2-set-up-gitlab-ci-for-your-repository" id="markdown-toc-part-2-set-up-gitlab-ci-for-your-repository">Part 2: Set up GitLab CI for your repository</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#part-3-build-your-code" id="markdown-toc-part-3-build-your-code">Part 3: Build your code</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#part-4-run-the-tests" id="markdown-toc-part-4-run-the-tests">Part 4: Run the tests</a>        <ul>
          <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#step-1-run-the-unit-and-integration-tests" id="markdown-toc-step-1-run-the-unit-and-integration-tests">Step 1: Run the unit and integration tests</a></li>
          <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#step-2-run-the-end-to-end-tests-optional" id="markdown-toc-step-2-run-the-end-to-end-tests-optional">Step 2: Run the end-to-end tests (optional)</a></li>
        </ul>
      </li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#part-5-update-configuration" id="markdown-toc-part-5-update-configuration">Part 5: Update configuration</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#submission-checklist" id="markdown-toc-submission-checklist">Submission checklist</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#stretch-security-scan" id="markdown-toc-stretch-security-scan">(Stretch) Security scan</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#stretch-test-coverage" id="markdown-toc-stretch-test-coverage">(Stretch) Test coverage</a></li>
      <li><a href="https://project-exercises.devops.corndel.com/exercises/m7_exercise_gitlab#stretch-send-slack-notifications" id="markdown-toc-stretch-send-slack-notifications">(Stretch) Send Slack notifications</a></li>
    </ul>
  </li>
</ul>

<p>In this exercise, you will set up continuous integration for your app using GitLab CI/CD. You’ll set up a pipeline which will build a Docker image and use it to run your tests.</p>

<h2 id="part-1-testing-in-docker">Part 1: Testing in Docker</h2>

<p>Running your tests in a CI pipeline is going to involve a lot of dependencies. You’ll need a Python binary (of the correct version), the standard library, Poetry, third-party Python packages.</p>

<blockquote>
  <p>Additionally, if you have any end-to-end tests, you also need a browser and a webdriver that can run in “headless” mode (i.e. without a GUI).</p>
</blockquote>

<p>That’s a lot, and you shouldn’t rely on a CI/CD tool to provide a complex dependency chain like this. Instead, we’ll use Docker to build, test and deploy our application. GitLab won’t even need to know it’s running Python code! We instead just need the job runner to be able to build images/run containers. This has a few advantages:</p>

<ul>
  <li>Our CI configuration will be much simpler</li>
  <li>It’s easier to move to a different CI/CD tool in future</li>
  <li>We have total control over the build and test environment via our Dockerfile</li>
</ul>

<p>Conveniently we’ve already containerised our application in module 5 and so all we need to do is add another build stage to the Dockerfile for testing:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FROM</span> <span class="n">base</span> <span class="k">as</span> <span class="n">test</span>

<span class="n">ENTRYPOINT</span> <span class="n">poetry</span> <span class="n">run</span> <span class="n">pytest</span>
</code></pre></div></div>
<p>This assumes that you only have unit and integration tests and all your test-related files have been copied in the <code class="language-plaintext highlighter-rouge">base</code> build stage (if not you’ll need to add an extra <code class="language-plaintext highlighter-rouge">COPY</code> command).</p>
<ul>
  <li>For more detailed instructions (including how to containerise end to end tests) please checkout <a href="https://faq.devops.corndel.com/Modules/Module_5/Project_Exercise/testing_in_docker.html">the FAQs site</a></li>
</ul>

<h2 id="part-2-set-up-gitlab-ci-for-your-repository">Part 2: Set up GitLab CI for your repository</h2>

<p>When using GitLab SaaS (instead of self-hosted) there is a free tier for CI with a limited number of minutes per month. You can also host your “runners” - you run a program on your own machine, register it with your GitLab instance and then it will run jobs as appropriate. The free runners should be plenty for your to-do app, so there’s no need to create your own runners for this exercise.</p>

<p>Switching on GitLab CI/CD is just a matter of including a valid <a href="https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html">pipeline configuration file</a>. Create a file called <code class="language-plaintext highlighter-rouge">.gitlab-ci.yml</code> at the root of your project. This file will define your “pipeline” - a series of jobs you want to automatically run. It uses the <a href="https://docs.fileformat.com/programming/yaml/">YAML data format</a>.</p>

<p>Here is a very simple pipeline file, followed by an explanation:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stages</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">test</span>

<span class="na">my-job</span><span class="pi">:</span>
  <span class="na">stage</span><span class="pi">:</span> <span class="s">test</span>
  <span class="na">script</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">echo "Hello, world"</span>
</code></pre></div></div>

<p>At the top level there are two keys:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">stages</code> - a list of the stages in our pipeline</li>
  <li><code class="language-plaintext highlighter-rouge">my-job</code> - the name of this was chosen arbitrarily. It starts the definition of a “job”.</li>
</ul>

<p>That “job” specifies:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">stage</code> - the stage that the job belongs to. Stages group jobs together and the stages run in a strict order, each one starting after the previous one completes.</li>
  <li><code class="language-plaintext highlighter-rouge">script</code> - a list of shell commands to execute in order. This job just prints out the text “Hello, world”.</li>
</ul>

<p>Try using the example config above in your own yaml file. Commit and push the code, then check that the build ran successfully. To check the output of your build, go to your repository on the GitLab website and open up the CI/CD tab. The URL should be of the form <code class="language-plaintext highlighter-rouge">https://gitlab.com/&lt;your_username&gt;/&lt;your_repository&gt;/-/pipelines</code>. Click on a pipeline for details. Within the pipeline run, you see the result of each job. Click on a job to see all of its logs.</p>

<h2 id="part-3-build-your-code">Part 3: Build your code</h2>

<p>Replace the “echo” command with the correct command to build your test Docker image (target the “test” stage). But if you try running it now, it will fail because the runner doesn’t have access to Docker commands.</p>

<p>You can read <a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html">GitLab’s documentation for setting up Docker</a>, but here is the relevant information. If you were managing your own runner, you could give it permission to use Docker on your machine, but we’re using GitLab’s runner. So here’s what you need to do:</p>
<ul>
  <li>Specify that your pipeline should run in a container that has the Docker CLI installed. Do this by setting <code class="language-plaintext highlighter-rouge">image: docker</code> at the top of your YAML file. This will tell GitLab to use the <a href="https://hub.docker.com/_/docker/">“docker” image from Docker Hub</a>.</li>
  <li>Add a “service” - this is a container that runs alongside your job to provide extra functionality (in this case, a Docker daemon). Do this by adding <code class="language-plaintext highlighter-rouge">services: [ docker:dind ]</code> to the top of your YAML file. The tag “dind” stands for Docker in Docker and this container will be able to build Docker images and even run containers within itself.</li>
</ul>

<p>Now push your changes and check that the pipeline runs successfully. Your “docker build” command should now work because it is executed in a container with the CLI installed and it will connect to the “dind” service to actually do the building.</p>

<h2 id="part-4-run-the-tests">Part 4: Run the tests</h2>

<p>In exercise 3 you should have added some unit and integration tests to your project, and possibly some end-to-end tests too. You should by now have them running successfully in Docker (see the appendix if not). You will now update the CI pipeline to run those tests.</p>

<h3 id="step-1-run-the-unit-and-integration-tests">Step 1: Run the unit and integration tests</h3>

<p>Add one or more steps to your pipeline file in order to run the unit and integration tests. You should run the tests via Docker (i.e. <code class="language-plaintext highlighter-rouge">docker run ...</code> commands). Don’t try to install your project dependencies or execute pytest directly on the GitLab runner itself.</p>

<h3 id="step-2-run-the-end-to-end-tests-optional">Step 2: Run the end-to-end tests (optional)</h3>

<p>If you do not have end-to-end tests, you can skip this step. Or you could go back to the Module 3 project exercise and attempt that stretch goal!</p>

<p>Unlike your integration tests, end-to-end tests will need real Trello credentials. Make sure you handle the secrets properly! Locally you set these in the .env file, but the CI job has no .env file. To avoid committing credentials in the source code, add them to the GitLab repository as <a href="https://docs.gitlab.com/ee/ci/variables/#add-a-cicd-variable-to-a-project">CI variables</a>, through the GitLab website. These set environment variables for your pipeline. E.g. you could write <code class="language-plaintext highlighter-rouge">$YOUR_VARIABLE_NAME</code> in a command to access a CI variable you created.</p>

<p>There are two optional settings when adding a variable: “protect” and “mask”.</p>

<ul>
  <li>The variables you are adding now should <strong>not</strong> be “protected”. We want every branch to be able to run end-to-end tests. This could be useful for variables only certain branches need, like deployment credentials.</li>
  <li>When it is a sensitive variable, “mask” it to prevent it appearing in CI/CD logs since those are easy to access.</li>
</ul>

<p>In a <code class="language-plaintext highlighter-rouge">docker run</code> command, you can include a <code class="language-plaintext highlighter-rouge">-e</code> option for each environment variable instead of using <code class="language-plaintext highlighter-rouge">--env-file</code>. E.g. <code class="language-plaintext highlighter-rouge">docker run -e TRELLO_KEY=foo -e TRELLO_TOKEN=bar ...</code>. Make sure the environment variable names match what your app actually expects and replace foo/bar with the correct expressions to use your CI variables. Only add variables that your end-to-end tests need, and only pass in these sensitive values when running end-to-end tests. Other tests should still use the .env.test file.</p>

<p>If you have been consistent with your environment variable names, you might find you are writing e.g. <code class="language-plaintext highlighter-rouge">-e TRELLO_KEY=$TRELLO_KEY</code>. Docker has a shorthand for this: simply write <code class="language-plaintext highlighter-rouge">-e TRELLO_KEY</code>.</p>

<p>Values that are constant and not sensitive could be stored directly in the pipeline YAML file.</p>

<h2 id="part-5-update-configuration">Part 5: Update configuration</h2>

<p>Finally, configure the repository so that merge requests can only be merged once the pipeline has completed successfully:</p>
<ul>
  <li>Go to your repository in GitLab.</li>
  <li>Go to Settings &gt; General.</li>
  <li>Expand the “Merge requests” section.</li>
  <li>Tick the box for “Pipelines must succeed”</li>
</ul>

<h2 id="submission-checklist">Submission checklist</h2>

<p>A non-exhaustive list of things to check before submitting for review:</p>

<ul>
  <li>You can run all your tests inside Docker following instructions in your README.md file</li>
  <li>You have a passing GitLab CI pipeline that
    <ul>
      <li>runs whenever a branch is updated</li>
      <li>builds a docker image for testing</li>
      <li>runs all your tests (and the pipeline should fail if your tests fail)</li>
      <li>doesn’t reveal any secret values</li>
    </ul>
  </li>
  <li>Your submission still satisfies the criteria from previous exercises</li>
</ul>

<h2 id="stretch-security-scan">(Stretch) Security scan</h2>

<p>Security/dependency scans are a common feature of CI pipelines. Snyk is an example security scanning tool which we can add to a GitLab CI pipeline. <a href="https://app.snyk.io/login/">Create a free account</a> now. There are paid subscriptions as well, but the free account will provide enough runs for this exercise.</p>

<p>You could install the Snyk CLI and then run it as part of your pipeline, but they have developed an integration that provides a lot of extra functionality. You can read about what it does and how to use it from <a href="https://docs.snyk.io/integrations/git-repository-scm-integrations/gitlab-integration">their documentation</a>.</p>

<h2 id="stretch-test-coverage">(Stretch) Test coverage</h2>

<p>You can add <a href="https://docs.gitlab.com/ee/ci/testing/test_coverage_visualization.html">test coverage visualisation</a> to your GitLab repo to keep track of how much code is covered by your test suite, and even see the test coverage when reviewing the code in a merge request.</p>

<p>Follow the documentation for details, but in short you will need to:</p>
<ul>
  <li>Install the <code class="language-plaintext highlighter-rouge">pytest-cov</code> Python package</li>
  <li>Update your pipeline to run pytest with the <code class="language-plaintext highlighter-rouge">--cov</code> flag to generate a coverage report, and the <code class="language-plaintext highlighter-rouge">--cov-report</code> flag to specify a format for the output file.</li>
  <li>Update your pipeline file to save the coverage report as an “artifact”</li>
</ul>

<h2 id="stretch-send-slack-notifications">(Stretch) Send Slack notifications</h2>

<p>You can add a custom notification step to the pipeline, such as sending a Slack message whenever the job runs or at least whenever it fails. You can do this without knoweldge of the Slack API by using the <a href="https://docs.gitlab.com/ee/user/project/integrations/slack.html">Slack “integration”</a>.</p>


      <footer class="site-footer">
        <span class="site-footer-credits">© 2024 Corndel</span>
      </footer>
    </main>
  
</body></html>